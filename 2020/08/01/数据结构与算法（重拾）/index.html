<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法（重拾） | HappyBang</title><meta name="description" content="数据结构与算法（重拾）概念 什么是数据结构？ 广义上讲，数据结构就是指一组数据的存储结构  算法是什么？ 广义上讲，算法就是操作数据得一种方法  两者之间得关系？ 数据·结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。  数据结构知识点总结：  20个最常用知识点： 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10个算法：递归"><meta name="author" content="Bang Li"><meta name="copyright" content="Bang Li"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构与算法（重拾）"><meta name="twitter:description" content="数据结构与算法（重拾）概念 什么是数据结构？ 广义上讲，数据结构就是指一组数据的存储结构  算法是什么？ 广义上讲，算法就是操作数据得一种方法  两者之间得关系？ 数据·结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。  数据结构知识点总结：  20个最常用知识点： 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10个算法：递归"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法（重拾）"><meta property="og:url" content="http://yoursite.com/2020/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E6%8B%BE%EF%BC%89/"><meta property="og:site_name" content="HappyBang"><meta property="og:description" content="数据结构与算法（重拾）概念 什么是数据结构？ 广义上讲，数据结构就是指一组数据的存储结构  算法是什么？ 广义上讲，算法就是操作数据得一种方法  两者之间得关系？ 数据·结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。  数据结构知识点总结：  20个最常用知识点： 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10个算法：递归"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-31T17:57:13.000Z"><meta property="article:modified_time" content="2020-07-31T17:58:28.326Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E6%8B%BE%EF%BC%89/"><link rel="prev" title="写给那个心动女孩" href="http://yoursite.com/2020/08/03/%E5%86%99%E7%BB%99%E9%82%A3%E4%B8%AA%E5%BF%83%E5%8A%A8%E5%A5%B3%E5%AD%A9/"><link rel="next" title="单链表时间复杂度分析" href="http://yoursite.com/2020/07/29/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构与算法（重拾）"><span class="toc-number">1.</span> <span class="toc-text">数据结构与算法（重拾）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂度分析"><span class="toc-number">1.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">1.4.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">1.5.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-number">1.6.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-number">1.7.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">1.8.</span> <span class="toc-text">排序</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">HappyBang</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数据结构与算法（重拾）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-08-01 01:57:13"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-08-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-01 01:58:28"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-01</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="数据结构与算法（重拾）"><a href="#数据结构与算法（重拾）" class="headerlink" title="数据结构与算法（重拾）"></a>数据结构与算法（重拾）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>什么是数据结构？</p>
<p>广义上讲，数据结构就是指一组数据的存储结构</p>
</li>
<li><p>算法是什么？</p>
<p>广义上讲，算法就是操作数据得一种方法</p>
</li>
<li><p>两者之间得关系？</p>
<p>数据·结构和算法是相辅相成的，数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p>
</li>
<li><p>数据结构知识点总结：</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a1I2z8.md.jpg" alt="a1I2z8.md.jpg"></p>
<p>20个最常用知识点：</p>
<p>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；</p>
<p>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法；</p>
</li>
</ul>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul>
<li><p><strong>大O复杂度表示法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum = sum +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>首先我们估算一下这段代码，假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？</p>
<p>​        第2、3、4行代码，每一行都需要一个unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n * unit_time的执行时间，第7、8行代码循环执行了n²遍，所以需要2n² * unit_time的执行时间。所以，整段代码的执行时间为 T(n) = (2n²+2n+3)*unit_time。</p>
<blockquote>
<p><strong>大O表达式： T(n) = O(f(n))</strong></p>
<p>T(n)：代码执行的时间</p>
<p>n：数据规模的大小</p>
<p>f(n)：每行代码执行次数的总和</p>
<p>O：代表每个语句执行的时间</p>
</blockquote>
<p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以也叫做<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p>
</li>
</ul>
<ul>
<li><p><strong>时间复杂度分析</strong></p>
<p>三个比较实用的方法：</p>
<p><strong>1、只关注循环次数最多的一段代码</strong></p>
<p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。</strong>这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
<p><strong>2、加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p>
<p>注意一点，只要是一个已知的数，都属于常量级的执行时间。在大O表达式钟都能忽略。</p>
<p>规律的抽象公式：如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p><strong>3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p>
<p>可以把乘法法则看成是嵌套循环，例如：T1(n) = O(n)，T2(n) = O(n²)，则 T1(n) * T2(n) = O(n³)。</p>
</li>
<li><p><strong>几种常见复杂度分析</strong></p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/27/aP5pss.jpg" alt="aP5pss.jpg"></p>
<p>复杂度量级我们可以分为两类：多项式量级和非多项式量级。非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)</p>
<p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p>
<p>当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，所以非多项式时间复杂度的算法其实是非常低效的算法</p>
<p><strong>几种常用的多项式时间复杂度：</strong></p>
<p><strong>1、O(1)</strong></p>
<p>首先，O(1)只是常量级时间复杂度的一种表示，并不代表只执行一行代码。</p>
<p>总结一下：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度就是Ο(1)。</p>
<p><strong>2、O(logn)、O(nlogn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三行循环的次数最多，只用看第三行。</p>
<p>每次增加都是乘以2，所以循环的次数就是2<sup>x</sup> = n ，所以循环次数x为log<sub>2</sub> n，因为对数之间是可以相互转换的，所以我们把对数的时间复杂度统一记作O(logn)；</p>
<p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<p><strong>3、O(m+n)、O(m*n)</strong></p>
<p>代码的复杂度由两个数据的规模决定</p>
<p>当无法正确评估m与n的量级时，代码的复杂度就为O(m+n)，加法法则不成立</p>
<ul>
<li><p>空间复杂度分析</p>
<p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。</p>
<p>看代码申请空间的大小，常见空间复杂度是O(1)、O(n)、O(n<sup>2</sup> )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p>
</li>
<li><p>复杂度总结</p>
<p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略表示，越高阶复杂度的算法，执行效率越低。从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/07/28/akWUfO.jpg" alt="akWUfO.jpg"></p>
<ul>
<li><p>小总结分析规律</p>
<p>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</p>
</li>
<li><p><strong>最好、最坏情况时间复杂度</strong></p>
<p>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。</p>
<p>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。</p>
</li>
<li><p><strong>平均情况时间复杂度</strong></p>
<p>需要引入概率论中的概率知识，概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p>
</li>
<li><p><strong>均摊时间复杂度</strong></p>
<p>对应的分析方法：摊还分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，实现了一个往数组中插入数据的功能，当数据满了之后，对数组进行求和，并将求和结果放在数组第一位，如果一开始数组空闲，则直接插入数据。</p>
<p>平均时间复杂度：O(1)</p>
<p><a href="https://imgchr.com/i/aAiZHs" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aAiZHs.jpg" alt="aAiZHs.jpg"></a></p>
<p>分析：find()和insert()的区别在于，find()在极端条件下，复杂度才为O(1)，insert()在大部分情况下复杂度都为O(1)；对于insert()来说，O(1)和O(n)出现是有规律的，一般都是O(n)插入之后，接着跟n-1个O(1)的插入操作。</p>
<p>针对这一情景，引入摊还分析法，也叫均摊时间复杂度。</p>
<p>每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。</p>
<p><strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></li>
</ul>
<p>线性表：数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>
<p><img src="https://s1.ax1x.com/2020/07/28/aAkytI.jpg" alt="aAkytI.jpg"></p>
<p>非线性表：比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p><img src="https://s1.ax1x.com/2020/07/28/aAAEuD.jpg" alt="aAAEuD.jpg"></p>
<p><strong>连续的内存空间和相同类型的数据。</strong>这两个限制使数组有一个特性：“随机访问”。不过也让数据有一些操作变得低效，比如插入或者删除一个数据，就需要做大量数据搬移工作。</p>
<ul>
<li><p><strong>数组是如何实现下标随机访问元素的呢？</strong></p>
<p>比如一个长度为10的int类型的数组int[] a = new int[10]。如图所示，计算机给这个数组分配了一块连续内存空间1000-1039。</p>
<p><a href="https://imgchr.com/i/aAd610" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aAd610.md.jpg" alt="aAd610.md.jpg"></a></p>
<p>计算机是通过地址来访问内存中的数据。当我们需要随机访问数组中某个元素时，首先会通过下面的寻址公式，计算出该元素的内存地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p>
<p>注意一个点：数组适合查找操作，但查找的时间复杂度并不为O(1)。即便是排好的数组，用二分法查找，时间复杂度也是O(logn)。正确的应该是，数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</p>
</li>
<li><p><strong>低效的插入操作</strong></p>
<p>如果在开头插入数据，所有的数据都需要往后移动一位，此时的时间复杂度为O(n)，如果在末尾插入数据，此时不需要移动数据，复杂度为O(1)。有一种情况，当数组中存储的数据没有任何规律，数组只是被当作一个存储数据的集合。我们将要插入的元素放在k位置，将k位置元素放到最后。这样复杂度会降到O(1)。</p>
<p><a href="https://imgchr.com/i/aEcMZt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aEcMZt.md.jpg" alt="aEcMZt.md.jpg"></a></p>
</li>
<li><p><strong>低效删除操作</strong></p>
<p>同插入一样，删除开头元素和末尾元素时间复杂度不同。平均复杂度也为O(n)。</p>
<p>如果在特定情况下，我们将多次删除操作集中在一起执行，删除效率会不会提高很多呢？</p>
<p><a href="https://imgchr.com/i/aEcrJU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/28/aEcrJU.md.jpg" alt="aEcrJU.md.jpg"></a></p>
<p>​        为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<p>其实这个删除的思想就是<strong>JVM 标记清除垃圾回收算法的核心思想</strong>。</p>
</li>
<li><p><strong>数组越界问题</strong></p>
<p>在C语言中，数组越界是有一种未决行为，并没有规定编译器应该怎么处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。所以可能会导致无限循环的行为。</p>
<p>在JAVA中，会做越界检查，发现越界会抛出java.lang.ArrayIndexOutOfBoundsException的异常。</p>
</li>
<li><p><strong>容器能否完全替代数组？</strong></p>
<p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。</p>
<p>ArrayList的优势在于<strong>可以将多数组的操作细节封装起来</strong>，比如一些插入和删除操作；还有一个优势就是<strong>支持动态扩容</strong>。</p>
<ul>
<li>扩容问题：</li>
</ul>
<p>​        数组定义的时候需要预先指定大小，否则大小不够时，我们就需要重新分配一块更大的空间，将原来的数据复制进去，然后再将新的数据插入。</p>
<p>​        ArrayList完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次存储空间不够时，都会将空间自动扩容1.5倍大小。因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在<strong>创建 ArrayList 的时候事先指定数据大小</strong>。</p>
</li>
<li><p>数组的一些使用情况：</p>
<p>1、Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p>
<p>2、如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p>
<p>3、还有就是一些个人喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array</p>
</li>
<li><p>总结：对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
</li>
<li><p><strong>数组下标为什么从0开始？</strong></p>
<p>以下是一种说法：</p>
<p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + k * type_size</span><br></pre></td></tr></table></figure>

<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure>

<p>对比两个公式可以发现，从1开始编号，每次随机访问数组都多了一次减法运算，对于CPU来说就是多了一次减法指令。数组作为非常基础的数据结构，效果优化就要尽量达到极致。所以选择下标从0开始。</p>
<p>当然，C语言设计者是用0作为下标的，之后的语言也延续这种习惯也是一种原因。</p>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p><strong>LRU缓存淘汰算法</strong></p>
<p>常见的缓存淘汰策略：</p>
<p>1、先进先出策略 FIFO（First In，First Out）</p>
<p>2、最少使用策略 LFU（Least Frequently Used）</p>
<p>3、最近最少使用策略 LRU（Least Recently Used）</p>
</li>
<li><p><strong>对比数组和链表</strong></p>
<p>我们从底层的存储结构来看看：</p>
<p><a href="https://imgchr.com/i/aVD9vn" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVD9vn.md.jpg" alt="aVD9vn.md.jpg"></a></p>
<p>图中可以看出，如果我们申请一个100 MB大小的数组，当内存没有连续的、足够大的存储空间时，即便剩余总空间大于100 MB，仍会申请失败。链表则相反，将一组零散的内存块串联起来使用，如果我们申请的是100 MB 大小的链表，完全没问题。</p>
</li>
<li><p><strong>三种最常用的链表结构：</strong></p>
<p>单链表、双向链表和循环链表</p>
<p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的”结点”。为了将所有结点串联起来，每个链表结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把记录下个结点的指针叫做<strong>后继指针next</strong>。</p>
<p><a href="https://imgchr.com/i/aVDoIU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVDoIU.md.jpg" alt="aVDoIU.md.jpg"></a></p>
<p>从图中可知，有两个结点比较特殊，第一个结点<strong>头结点</strong>和最后一个结点<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。可以通过头结点遍历得到整条链表。尾结点则是指向一个<strong>空地址NULL</strong>。</p>
<p>链表的插入和删除操作对应的时间复杂度都是O(1)——这里说法不一定准确，详情看另一篇：单链表时间复杂度解析</p>
<p><a href="https://imgchr.com/i/aVrmo8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVrmo8.md.jpg" alt="aVrmo8.md.jpg"></a></p>
<p>而链表的查询就比较复杂了，需要的时间复杂度为O(n)</p>
<p>可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p>
<p><strong>循环链表</strong>是一种特殊的单链表。单链表将尾结点指针指向头结点，就是一个循环链表。</p>
<p><a href="https://imgchr.com/i/aVrtoT" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVrtoT.md.jpg" alt="aVrtoT.md.jpg"></a></p>
<p><strong>双向链表</strong>，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p><a href="https://imgchr.com/i/aVrDyR" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVrDyR.md.jpg" alt="aVrDyR.md.jpg"></a></p>
<p>从图可知，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，存储同样多的数据，双向链表比单链表占用更多的内存空间，但支持双向遍历，也能解决一些灵活性不足的问题。</p>
<p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>
</li>
<li><p>讲讲（单、双向链表）删除操作</p>
<p>删除一个数据有两种情况：</p>
<p>1、删除结点中“值等于某个给定值”的结点；</p>
<p>2、删除给定指针指向的结点。</p>
<p>对于第一种情况，单双链表都需要从头结点开始一个一个遍历，直到找到给定值的结点。复杂度均为O(n)</p>
<p>对于第二种情况，我们已经找到了要删除的结点，但是删除结点需要知道其前驱结点，单链表并不支持直接获取前驱结点，所以还是要从头结点开始遍历链表，直到p -&gt; next = q。但对于双向链表来说，双向链表可直接得到前驱结点，所以时间复杂度为O(1)，而单链表则为O(n)。</p>
<p>插入操作也同理分析</p>
</li>
<li><p>讲讲（单、双向链表）查询操作</p>
<p>对于一个有序链表，双向链表的查询效率也高于单链表。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p>
<p>在Java语言中，LinkedHashMap 的实现原理就用到了双向链表这种数据结构。</p>
</li>
<li><p>用空间换时间的设计思想</p>
<p>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p>
<p>总结：对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p>
</li>
<li><p>链表和数组的性能比较</p>
<p><a href="https://imgchr.com/i/aVc89U" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVc89U.md.jpg" alt="aVc89U.md.jpg"></a></p>
<p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p>
<p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p>
</li>
<li><p>基于链表实现LRU缓存淘汰算法</p>
<p>思路：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<p>1、如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p>
<p>2、如果此数据没有在缓存链表中，又可以分为两种情况：</p>
<p>​    如果此时缓存未满，则将此结点直接插入到链表的头部；</p>
<p>​    如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p>
<p>此时的时间复杂度为O(n)，可以思考用散列表将时间复杂度优化到O(1)</p>
</li>
</ul>
<ul>
<li><p>写链表代码的技巧</p>
<ul>
<li><p>技巧一：理解指针或者引用的含义</p>
<p>实际上，不管是指针还是引用，意思都是存储所指对象的内存地址。C语言指针的概念就等于其他语言中的引用。</p>
<p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
</li>
<li><p>技巧二：警惕指针丢失和内存泄漏</p>
<p>来看简单的插入案例：</p>
<p><img src="https://s1.ax1x.com/2020/07/29/aVc6jH.md.jpg" alt="aVc6jH.md.jpg"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x;  // 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next = p-&gt;next;  // 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure>

<p>这个代码是错误的，p-&gt;next 指针在完成第一步操作之后，已经不再指向b了，而是指向x。而第二步就是将x赋值给x-&gt;next。导致整个链表断成两部分。将一二行代码互换即可解决，所以应该注意代码的顺序问题！</p>
<p>同理，删除链表结点时，也一定要记得手动释放内存。否则会出现内存泄漏问题，不过在Java这种虚拟机自动管理内存的编程语言，就不需要考虑这么多。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>技巧三：利用哨兵简化实现难度</p>
<p>回顾下单链表的插入和删除操作：</p>
<p>结点p后插入一个新的结点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br></pre></td></tr></table></figure>

<p>如果向空链表插入第一个节点，插入代码会不同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">  head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除结点p的后继结点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure>

<p>删除链表最后一个结点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (p-&gt;next == null) &#123;</span><br><span class="line">   p = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>
<p>引入哨兵结点，不管链表是否为空，head都会指向这个哨兵结点我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p>
<p><a href="https://imgchr.com/i/aVgp2F" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/29/aVgp2F.md.jpg" alt="aVgp2F.md.jpg"></a></p>
<p>如图，哨兵结点是不存储数据的。因为哨兵结点的存在，所以’’边界问题’’得以解决。</p>
</li>
</ul>
<ul>
<li><p>技巧四：重点留意边界问题处理</p>
<p>一般检查代码是否正确的边界条件有这样几个：</p>
<p>如果链表为空时，代码是否能正常工作？</p>
<p>如果链表只包含一个结点时，代码是否能正常工作？</p>
<p>如果链表只包含两个结点时，代码是否能正常工作？</p>
<p>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</p>
</li>
</ul>
<ul>
<li><p>技巧五：举例画图、辅助思考</p>
<p><img src="https://s1.ax1x.com/2020/07/29/aV2AyQ.md.jpg" alt="aV2AyQ.md.jpg"></p>
<p>画出插入数据前和插入数据后，可以更清楚看出逻辑思路</p>
</li>
</ul>
<ul>
<li><p>技巧六：练习</p>
<p>五种常见链表操作：</p>
<ul>
<li>单链表反转</li>
<li>链表中环的检测</li>
<li>两个有序的链表合并</li>
<li>删除链表倒数第n个结点</li>
<li>求链表的中间结点</li>
</ul>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p><strong>栈结构：</strong></p>
<p>后进先出、先进后出。</p>
<p>从操作上来看，栈是一种”操作受限”的线性表，只允许在一端插入和删除数据</p>
</li>
<li><p><strong>如何实现一个”栈”</strong></p>
<p>栈可以用数组来实现，也可以用链表来实现。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链式栈</p>
<p>一个基于数组的顺序栈（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度：O(1)</p>
<p>时间复杂度：O(1)</p>
</li>
<li><p><strong>支持动态扩容的顺序栈</strong></p>
<p><a href="https://imgchr.com/i/aMINtK" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/31/aMINtK.md.jpg" alt="aMINtK.md.jpg"></a></p>
<p>对于出栈操作的时间复杂度：O(1)</p>
<p>对于入栈操作：</p>
<p>1、当栈中空间充足：时间复杂度为O(1)</p>
<p>2、当空间不够时，要重新申请内存和数据搬移，时间复杂度变为O(n)</p>
<p>用摊还分析法进行分析：</p>
<ul>
<li><p>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</p>
</li>
<li><p>为了简化分析，假设只有入栈操作没有出栈操作；</p>
</li>
<li><p>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</p>
</li>
</ul>
<p>如果当前栈空间为K，已满后申请两倍大的内存，并且做K个数据的搬移。</p>
<p><a href="https://imgchr.com/i/aMoWUx" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/31/aMoWUx.md.jpg" alt="aMoWUx.md.jpg"></a></p>
<p>所以，入栈操作的均摊复杂度为O(1)</p>
</li>
<li><p><strong>栈在函数调用中的使用</strong></p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   printf(<span class="string">"%d"</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/07/31/aMqufx.md.jpg" alt="aMqufx.md.jpg"></p>
<p>​    图中显示的是，执行到add()函数时，函数调用栈的情况</p>
<ul>
<li><p><strong>栈在表达式求值中的应用</strong></p>
<p>编译器对于算数表达式的求值，通过两个栈来实现的。一个保存操作数的栈，一个保存运算符的栈。从左向右遍历表达式，遇到数字直接压入操作数栈，遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aMvGFJ.md.jpg" alt="aMvGFJ.md.jpg"></p>
</li>
<li><p><strong>栈在括号匹配中的应用</strong></p>
<p>栈可以用来检查表达式中的括号是否匹配</p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有括号都扫描完成，如果栈为空，则说明字符串为合法格式，否则为非法格式。</p>
</li>
</ul>
</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li><p><strong>队列理解：</strong></p>
<p>先进先出就是队列</p>
<p>支持两个基本操作：入队(enqueue)，放一个数据到队列尾部；出队(dequeue)：从列表头部取一个数据</p>
<p>跟栈一样，也是一种受限制的线性表数据结构</p>
<p>用数组实现的叫做顺序队列，用链表实现的叫做链式队列</p>
</li>
<li><p><strong>队列实现(Java)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head表示队头下标，tail表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span></span><br><span class="line">    String ret = items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列需要两个指针，一个head指针指向队头，一个tail指针指向队尾</p>
<p>下图为a、b、c、d依次入队后的状态：</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQMNLT.md.jpg" alt="aQMNLT.md.jpg"></p>
<p>调用两次出队的操作：</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQQ9lq.md.jpg" alt="aQQ9lq.md.jpg"></p>
<p>随着不断地出队和入队，tail移动到最右边时我们无法再往队列中添加元素，而队列可能还有很多空闲位置。如何在不用数据搬移的情况下，优化一下队列，合理利用空闲位置，并且保持时间复杂度为O(1)</p>
<p>修改一下入队函数即可以实现优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作，将item放入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// tail == n表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">      items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新head和tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当tail指针移动到数组的最右边时，如果有新的数据入队，我们将head和tail之间的数据，搬移到0到tail-head的位置</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQ1H61.md.jpg" alt="aQ1H61.md.jpg"></p>
<p><strong>基于链表的队列实现：</strong></p>
<p>我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQ3Kcn.md.jpg" alt="aQ3Kcn.md.jpg"></p>
</li>
<li><p><strong>循环队列</strong></p>
<p>循环队列能完美解决数据搬移的问题</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQG8W4.md.jpg" alt="aQG8W4.md.jpg"></p>
<p>当tail移动到7且继续入队时，会在0位置继续添加新的数据</p>
<p>写好循环队列的关键在于：<strong>确定好队空和队满的判定条件。</strong></p>
<p>队空的判定条件仍然为：tail == head</p>
<p>队满时候的状态图：</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQJZtO.md.jpg" alt="aQJZtO.md.jpg"></p>
<p>此时tail=3，head=4，n=8，(3+1)%8=4，得出结论(tail+1)%n=head</p>
<p>当队满时，图中tail指向的位置实际上没有存储数据，所以，循环队列会浪费一个数组的存储空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head表示队头下标，tail表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为capacity的数组</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String ret = items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>阻塞队列和并发队列</strong></p>
<p>阻塞队列其实就是在队列的基础上加了阻塞操作。简单来说，在队列为空的时候，从队头取数据会被阻塞。队列满了，插入数据的操作也会被阻塞，直到有空闲位置。</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQa61S.md.jpg" alt="aQa61S.md.jpg"></p>
<p>上述的定义就是一个”生产者 - 消费者模型”！可以有效协调生产和消费的速度。可以通过协调”生产者”和”消费者”的个数，来提高数据的处理效率。配置多个”消费者”来对应一个”生产者”。</p>
<p><img src="https://s1.ax1x.com/2020/07/31/aQd3Hs.md.jpg" alt="aQd3Hs.md.jpg"></p>
<p>线程安全的队列我们叫做<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li><p><strong>递归需要满足的三个条件：</strong></p>
<p>1、一个问题的解可以分解为几个子问题的解</p>
<p>2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p>
<p>3、存在递归终止条件</p>
</li>
<li><p><strong>如何编写递归代码</strong></p>
<p>写出递归公式、找到终止条件</p>
<p>台阶问题：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>
<p>思考：可以根据第一步的走法把所有走法分为两类，第一类是第一步走了一个台阶，另一类是第一步走了两个台阶</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 递归公式</span><br><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure>

<p>有了递归公式，就只需要终止条件了。因为有两种不同的走法，终止条件就为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1;</span><br><span class="line">f(2) &#x3D; 2;</span><br></pre></td></tr></table></figure>

<p>最终代码的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
</li>
<li><p><strong>一些注意点：</strong></p>
<p>1、递归代码要警惕堆栈溢出</p>
<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈一般都不大。如果递归求解的数据规模很大，调用层次深一直压入栈，就会有栈堆溢出风险</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># java中的报错</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<p>2、递归代码要警惕重复计算</p>
<p><img src="https://s1.ax1x.com/2020/07/31/a13Y9g.md.jpg" alt="a13Y9g.md.jpg"></p>
<p>从图中可知f(3)被计算了多次</p>
<p>可以通过一个数据结构（散列表）来保存已经求解过的f(k)。当递归调用到f(k)时，看下是否已经求解过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么将递归代码改写为非递归代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是改成循环自己实现出栈入栈的操作</p>
</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li><p><strong>排序算法的分类</strong></p>
<p><img src="https://s1.ax1x.com/2020/08/01/a1oZeH.md.jpg" alt="a1oZeH.md.jpg"></p>
<p>插入排序和冒泡排序复杂度相同，为什么我们在实际开发中更倾向于用插入排序呢？</p>
</li>
<li><p><strong>对一个排序算法进行分析</strong></p>
<p>排序算法的执行效率：</p>
<p>1、最好情况、最坏情况、平均情况时间复杂度</p>
<p>2、时间复杂度的系数、常数 、低阶</p>
<p>3、比较次数和交换（或移动）次数</p>
</li>
</ul>
<p>  排序算法的内存消耗：</p>
<p>  针对排序算法的空间复杂度，引入一个新概念——<strong>原地排序</strong>。特指空间复杂度时O(1)的排序算法。</p>
<p>  排序算法的稳定性：</p>
<p>  这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>
<p>  例子：比如先按时间排序的订单，再按金额进行排序，这时候就要确保两个金额相同的订单顺序不发生变化。</p>
<p>  <img src="https://s1.ax1x.com/2020/08/01/a1oaYq.md.jpg" alt="a1oaYq.md.jpg"></p>
<ul>
<li><p><strong>冒泡排序（Bubble Sort）</strong></p>
<p>冒泡排序只会操作相同的两个数据。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a1oD6U.md.jpg" alt="a1oD6U.md.jpg"></p>
<p>本质就是每次排序都将最大的选出来放在数组后面，实际上冒泡排序可以进行优化，当某次冒泡排序已经没有数据进行交换时，说明已经达到完全有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：冒泡排序是原地排序算法；冒泡排序是稳定的排序算法</p>
<p>​            冒泡排序的最好情况时间复杂度为O(n)，最坏时间复杂度为O(n<sup>2</sup>)</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a1oTne.md.jpg" alt="a1oTne.md.jpg"></p>
<p>​            计算一下平均时间复杂度：</p>
<p>​            我们需要引入一个”有序度”和”逆序度”的概念</p>
<p>​            有序度：数组中具有有序关系的元素对的个数。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a1oOht.md.jpg" alt="a1oOht.md.jpg"></p>
<p>​            同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，            3，4，5，6，有序度就是 n<em>(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作*</em>满有序度**。</p>
<p>​            公式：<strong>逆序度 = 满有序度 - 有序度。</strong></p>
<p>​            冒泡排序中包含两个操作原子：比较和交换。每交换一次，有序度就加一。不管算法怎么改，交换的次数都是确定            的，即为逆序度，也就是<strong>n*(n-1)/2–初始有序度</strong>。平均交换次数：n*(n-1)/4，所以可以推出平均时间复杂度为O(n)。</p>
</li>
</ul>
<ul>
<li><p><strong>插入排序（Insertion Sort）</strong></p>
<p>排序思想：</p>
<p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a17Ead.md.jpg" alt="a17Ead.md.jpg"></p>
<p>插入排序也包含两种操作：元素的比较和元素的移动。</p>
<p>移动操作的次数也等于这个数组的逆序度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>插入排序是一个原地排序；</p>
<p>对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
<p>如果数据是有序的，我们<strong>从尾到头</strong>在有序数据组里面查找插入位置，最好的时间复杂度为O(n)。</p>
<p>当倒序的时候，最坏时间复杂度为O(n<sup>2</sup>)</p>
</li>
</ul>
<ul>
<li><p><strong>选择排序（Selection Sort）</strong></p>
<p>实现思路：分已排序区间和未排序区间。选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p><img src="https://s1.ax1x.com/2020/08/01/a17so9.md.jpg" alt="a17so9.md.jpg"></p>
<p>总结：</p>
<p>选择排序是一种原地排序算法。</p>
<p>最好、最坏、平均时间复杂度都为：O(n<sup>2</sup>)</p>
<p>是一种不稳定的排序算法。</p>
</li>
<li><p>最后回答开篇问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序需要三个赋值操作，插入排序只需要一个赋值操作</p>
<p>所以从执行的单位时间上来看，插入排序是要远快于冒泡排序的。</p>
<p>插入排序也还有很大的优化空间，可以了解一下希尔排序。</p>
</li>
</ul>
<p>未完待续……</p>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bang Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E6%8B%BE%EF%BC%89/">http://yoursite.com/2020/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E6%8B%BE%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/08/03/%E5%86%99%E7%BB%99%E9%82%A3%E4%B8%AA%E5%BF%83%E5%8A%A8%E5%A5%B3%E5%AD%A9/"><img class="prev_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">写给那个心动女孩</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/29/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">单链表时间复杂度分析</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Bang Li</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>